* tasks:

  * technical
    * fix D3D11 errors

    * logging
      * have a list of different logs and make an interface for reading those logs
      * logs can create notifications if something bad happens
      * per frame log - reset it every frame :)
      * export to clipboard

    * console
      * command history
      * tab completion
      * scrolling
      * move output history to generic logging thing

    * global error state/error.h

    * abstract renderer
      * move to using adstracted renderer

    * cleanup renderer
      * port shaders to cleaned up renderer
        * card_render
        * debug_draw_world
        * debug_line_draw
        * field_of_vision
        * imgui
        * particles
        * pass_through_output
        * pixel_art_upsampler
        * sprite_sheet
      * port textures to be loaded from PNG
        * creatures
        * tiles
        * effects_24
        * effects_32
        * boxy_bold
      * load PNG assets at runtime
      * load shaders from text files at run time
        * should be able to start up if we only compile a subset of all shaders
        * output shader compile errors to a log
        * attempt shader reloads, don't reload shaders if they previously had 
          a working version but now don't

    * asset reloading at runtime
      * load asset through asset manager?
      * asset manager watches for changes that require that asset be reloaded?

    * cleanup
      * prelude.h/stdafx.h
      * draw -> render, folder for renderers

    * deprecate use of assets.bin for non-release candidates
      * load sounds from wave files at run time

    * get stack traces from assertion failures!!!
    * asynchronous sound loading
    * deprecate use of Python scripts in build system

    * libraries
      * something for threading! (threads.h?)
      * libogg

    * memory allocation
      * create a "large chunk allocator" for the assets manager and start loading/caching
        files into this area (perhaps we want to eventually have a strategy of having an
        assets file which is loaded in compressed format which remains resident in memory
        if all compressed assets are small?)

    * physics system
      * debug/create unit tests

  * editor
    * animation editor
    * dungeon generator editor
    * card editor
    * enemy editor

  * variable move duration depending on user input frequency
    * animation "speeding up" when moves made rapidly
  * improve imgui
    * global context
    * debug imgui global context
    * member functions
  * card user interface
    * card discarding
  * hide mouse/use custom mouse cursor
  * hold tab to view entity health
  * transaction processing
    * only collapse "Entity_Damage" events after processing transactions
  * "rational" class?

* scenarios:
  * field of vision
    * visible
    * previously seen (show tiles but not creatures)
    * never seen (don't show tiles)
  * invisible wall
  * fireball hits barrels, chain reaction
  * enemies
    * spiders (traps)
    * some creature with an attack which "pulls" the player towards them (e.g. a frog with a tongue attack)
  * doors
    * open/close field of vision
  * spells/cards
    * magic missile
    * fireball
    * lightning (bounces off walls etc)
    * teleport sphere (chaos sphere?)
    * cloud/grease
    * freeze
    * flesh to stone
    * disease (card can't be discarded)
  * improve anims etc
    * exchange
      * cast sound
      * "particle" effects
    * poison card (take damage, anims etc)
      * card flash
      * sound effect

* features
    * memory functions/context
    * global context/global error message
    * global context
        * thread local global context
    * strings
  * debug draw transparency

* cleanup
  * "stateless" DX11 usage
  * use precompiled header?

* bugs
  * "release" mode compile
  * don't try code reloading during debug pause
  * events not sent if mouse leaves window - need to turn off map dragging mode when re-entering the
    window
  * card renderer to do proper anti aliasing/alpha transparency (also mip mapping)
  * ending turn before card dealt animation finished

* decision
  * characters/items/tiles to be rendered pixel perfect (tile shader)
  * do mouse picking/outlining using this pixel perfect texture
  * effects/cards should use the fancier shader (sprite shader)

* sprite rendering (effects/cards)
  * tiles to be rendered with parameters:
    * horiz stretch
    * vertical stretch
    * rotation
    to be applied stretches first
  * correct pixel sampling (i.e. blend when a pixel overlaps edge of samples)
  * generate anisotropic mips (?)

* create a proper windows game loop
  * make jfg/input.h to convert input from windows to custom input format
    * read input from windows message loop and translate it to sensibly buffered input

* create xinput loading lib
